{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | Create URIs for various access points.
--
module API (targetSearch
           , scheduleOnDate

           , obsURI
           , obsURIString

           , linkToRecord
           , linkToRecordA
             
           , abstractLink
           , detailsLink

           , propTypeLink
             
           , tooLinkSearch
           , tooLinkSearchLong
             
           , instLinkSearch
           , gratLinkSearch
           , igLinkSearch
           , instLinkAbout
           , gratLinkAbout
             -- , igLinkAbout

           , constellationLinkSearch
           , typeLinkURI
           , typeDLinkURI
           , typeLinkSearch
           , typeDLinkSearch
           , basicTypeLinkSearch
           , categoryLinkSearch
           , nameLinkSearch
           , jointLinkSearch
           , constraintLinkSearch
             
           , renderLinks
           )
       where

import qualified Data.ByteString as B
import qualified Data.Text as T

import qualified Text.Blaze.Html5 as H
import qualified Text.Blaze.Html5.Attributes as A

import Text.Blaze.Html5 (AttributeValue, Html, textValue, toHtml)

import Blaze.ByteString.Builder (toByteString)

import Data.Char (intToDigit)
import Data.Maybe (fromJust, fromMaybe, isJust)
import Data.Monoid ((<>))
import Data.Text.Encoding (encodeUtf8)
import Data.Time.Calendar (Day)

import Network.HTTP.Types.URI (encodePath
                               , encodePathSegments
                               , simpleQueryToQuery)

import Types (ChipStatus(..)
             , ConShort(..)
             , ConLong(..)
             , Constraint(..)
             , ConstraintKind(..)
             , Instrument(..)
             , JointMission
             , Grating(..)
             , ObsIdVal(..)
             , PropCategory
             , Proposal(..)
             , PropType
             , Record
             , ScienceObs(..)
             , SimbadInfo(..)
             , SimbadType(..)
             , TargetName
             , TimeKS(..)
             , TOORequest(..)
             , TOORequestTime
             , fromMissionLongLink
             , getConstellationName
             , getJointObs
             , recordTarget, recordObsId
             , fromMission, toMission
             , fromPropType, toPropType
             , toPropTypeLabel
             , rtToLabel
             , simbadTypeToDesc
             , csToLabel, csToLC
               )
import Utils (addClass, cleanJointName, fromDay, showInt)

-- | Convert a record into the URI fragment that represents the
--   page for the record.
obsURI :: ObsIdVal -> AttributeValue
obsURI = textValue . obsURIString

obsURIString :: ObsIdVal -> T.Text
obsURIString (ObsIdVal oi) = "/obsid/" <> showInt oi

-- | Search for the given target. This is an exact (case insensitive)
--   search.
--
targetSearch :: TargetName -> AttributeValue
targetSearch name =
  "/search/name?target=" <> textValue name

-- | Show the schedule around the given date.
--
scheduleOnDate ::
  Day
  -- ^ The center of the schedule
  -> Int
  -- ^ The number of days before and after the day to
  --   include. It is expected that this is 0 or greater.
  -> AttributeValue
  -- ^ The path to use.
scheduleOnDate d n =
  let day = textValue (fromDay d)
      ndays = textValue (showInt n)
  in "/schedule/date/" <> day <> "/" <> ndays


linkToRecord :: Record -> Html
linkToRecord = linkToRecordA recordTarget

linkToRecordA ::
  H.ToMarkup a
  => (Record -> a)
  -> Record
  -> Html
linkToRecordA f r = 
  let uri = obsURI (recordObsId r)
  in (H.a H.! A.href uri) (toHtml (f r))


-- The following is in API since it needs access to obsURI

-- | Display the DSS/RASS/PSPC/WWT images and the observational
--   details (so the name is a slight mis-nomer).
--
-- The DSS/RASS/PSPC links are autogenerated using the following
-- scheme:
--
-- http://asc.harvard.edu/targets/<sequence>/<sequence>.<obsid>.soe.dss.gif
-- http://asc.harvard.edu/targets/<sequence>/<sequence>.<obsid>.soe.rass.gif
-- http://asc.harvard.edu/targets/<sequence>/<sequence>.<obsid>.soe.pspc.gif
--
-- We also display the observational details - in \"raw\" form - as a text box
-- as part of this section.
--
-- This is modified somewhat for discarded observations (not sure the best way to
-- do this at this time).
--
renderLinks :: 
  Bool -- True if current obs
  -> Maybe Proposal
  -> Maybe SimbadInfo
  -- ^ assumed to be for the observation
  -> ScienceObs
  -> Html
renderLinks f mprop msimbad so@ScienceObs{..} =
  let optSel :: T.Text -> Bool -> Html
      optSel lbl cf = 
        let idName = H.toValue (lbl <> "button")
            base = H.input H.! A.type_ "radio"
                           H.! A.name  "opttype"
                           H.! A.value (H.toValue lbl)
                           H.! A.id idName
                           H.! A.onclick
                               ("switchOption('" <> H.toValue lbl <> "')")
        in (if cf then base H.! A.checked "checked" else base)
           <> (H.label H.! A.for idName) (toHtml lbl)

      wwtLink = if f
                then (H.a H.! A.href "/wwt.html") "WWT"
                else (H.a H.! A.href (H.toValue (obsURI soObsId) <> "/wwt")) "WWT"

      form = addClass "radiobuttons" H.div $
              mconcat [ "View: "
                      , optSel "DSS" True
                      , optSel "RASS" False
                      , optSel "PSPC" False
                      , optSel "Details" False
                      , " or in "
                      , wwtLink
                      ]

      urlHead = "http://asc.harvard.edu/targets/"
                <> H.toValue soSequence
                <> "/"
                <> H.toValue soSequence
                <> "."
                <> H.toValue soObsId
                <> ".soe."

      link :: T.Text -> AttributeValue -> Bool -> Html
      link lbl frag af = 
        let uri = urlHead <> frag <> ".gif"
        in H.img H.! A.src    uri
                 H.! A.alt    (textValue ("The instrument field-of-view on top of the " <> lbl <> " image of the source."))
                 H.! A.width  (H.toValue (680::Int))
                 H.! A.height (H.toValue (680::Int))
                 H.! A.id     (textValue lbl)
                 H.! A.class_ (if af then "active" else "inactive")

  in form <>
     addClass "links" H.div
     (link "DSS" "dss" True <>
      link "PSPC" "pspc" False <>
      link "RASS" "rass" False <>
      renderObsIdDetails mprop msimbad so)

-- TODO:
-- Ideally we would link to something a bit more readable than the
-- archive page (ie its use of frames), and also present the link
-- in a more-friendly manner than as a link from the obsid or
-- sequence number.
--
viewerURI :: T.Text -> ObsIdVal -> AttributeValue
viewerURI opts ObsIdVal{..} =
  let base = "http://cda.cfa.harvard.edu/chaser/startViewer.do?menuItem="
  in textValue (base <> opts <> "&obsid=" <> showInt fromObsId)

obsIdLink :: ObsIdVal -> AttributeValue
obsIdLink = viewerURI "details"

detailsLink, abstractLink :: ObsIdVal -> AttributeValue
detailsLink = obsIdLink
abstractLink = viewerURI "propAbstract"

seqLink :: ObsIdVal -> AttributeValue
seqLink = viewerURI "sequenceSummary"
     
-- | Display detailed information about a science observation,
--   for those that just need to know the details.
--
--   Could try and link to the roll/pitch/slew GIF - e.g.
--   http://cxc.harvard.edu/targets/601090/601090.rollvis.gif
--   but it is not obvious how valid it is (since the above
--   does not cover May 2014 when that target was scheduled),
--   and it is rather meaningless to anyone but an expert.
--
--   I expect the proposal to always be available, but just
--   in case it isn't.
--
--   Note: for discarded observations, a "header" is added
--   to point this out, but the details are still included
--   "for fun".
--
renderObsIdDetails ::
  Maybe Proposal
  -> Maybe SimbadInfo
  -> ScienceObs
  -> Html
renderObsIdDetails mprop msimbad so@ScienceObs{..} =
  let name = soTarget
      inst = soInstrument
      grat = soGrating
      instInfo = instLinkSearch inst <>
                 if grat == NONE
                 then mempty
                 else ", " <> toHtml grat

      left = addClass "key" H.td
      right = addClass "value" H.td

      keyVal k v = H.tr (left k <> " " <> right v)

      oLink = H.a H.! A.href (obsIdLink soObsId) $ toHtml soObsId
      sLink = H.a H.! A.href (seqLink soObsId)   $ toHtml soSequence
      pLink = H.a H.! A.href ("/proposal/" <> H.toValue soProposal) $ toHtml soProposal

       -- rely on the ToMarkup instance of TimeKS
      expLink = case soObservedTime of
        Just t -> keyVal "Exposure (observed):" (toHtml t <> " ks")
        _ -> keyVal "Exposure (approved):" (toHtml soApprovedTime <> " ks")

      -- NOTE: can this be cleared up now that I have a better
      -- understanding of the jointwith and exposure-time fields?
      --
      missToLink mission = maybe (toHtml mission)
                           fromMissionLongLink (toMission mission)
                           
      toJ (l,v) = keyVal "Joint with:"
                  (missToLink l <> " for " <> toHtml (_toKS v) <> " ks")
                  
      jvs = getJointObs so

      jointElems = 
        if isJust soJointWith && null jvs
        then keyVal "Awarded Chandra time by:"
             (missToLink (cleanJointName (fromJust soJointWith)))
        else mconcat (map toJ jvs)

      cToL NoConstraint = "None" -- not used
      cToL Preferred    = "Preferred"
      cToL Required     = "Yes"
      clbls = ["Time critical:", "Monitor:", "Constrained:"]
      cvals = [soTimeCritical, soMonitor, soConstrained]
      constraintElems =
        let f (k,v) = keyVal k (cToL v)
        in mconcat (map f (filter ((/= NoConstraint) . snd) (zip clbls cvals)))

      conLink con = 
        let uri = H.toValue ("/search/constellation/" <> fromConShort con)
        in case getConstellationName con of
          Just ln -> Just ((H.a H.! A.href uri) (toHtml (fromConLong ln)))
          _ -> Nothing
        
      too = case soTOO of
        Just tr -> keyVal "Turnaround time:" (tooLinkSearch (Just (trType tr)))
        Nothing -> mempty

      -- the "chip" display depends on whether this has been archived or
      -- not (and if it's ACIS or HRC), since we display different things.
      chipDetails = case soDetector of
        Just dm -> keyVal "Chips:" (toHtml dm)
        _ -> fromMaybe mempty $ keyVal "Chips: " . toHtml <$> detector

      -- for now just convert to ACIS-??? treating optional as on
      detector = 
        if soInstrument `elem` [HRCI, HRCS]
        then Nothing
        else Just $ let sts = [ soACISI0, soACISI1, soACISI2, soACISI3,
                                soACISS0, soACISS1, soACISS2, soACISS3,
                                soACISS4, soACISS5
                              ]
                        ks = filter ((/= ChipOff) . snd) $ zip [0..] sts
                    in "ACIS-" ++ map (intToDigit . fst) ks

      -- assume they are both set or unset
      subArray = do
        start <- soSubArrayStart
        nrow <- soSubArraySize
        return $ keyVal "Sub Array:" $ toHtml ("Start: " <> showInt start <> " Rows: " <> showInt nrow)

      -- bundle several items into a single line
      propInfo Proposal {..} =
        let p0 = toHtml propType
            plink n = propTypeLink n Nothing
            ptype = maybe p0 plink (toPropType propType)
        in 
          keyVal "Proposal:"
          ("Cycle " <> toHtml propCycle <> ", "
           <> ptype <> ", "
           <> categoryLinkSearch propCategory propCategory
          )

      simbadInfo SimbadInfo {..} =
        keyVal "SIMBAD Type:" (typeDLinkSearch smiType3 smiType)
      
      discardRows = [ H.tr (addClass "note" H.td
                            "Note: the observation was discarded")
                    | soStatus == "discarded" ]

      tblRows =
        mconcat discardRows
        <>
        mconcat
          [ keyVal "Target:" (nameLinkSearch name)
          , maybe mempty simbadInfo msimbad
          , keyVal "Observation Details:" oLink
          , keyVal "Sequence Summary:" sLink
          , keyVal "Proposal Id:" pLink
          , maybe mempty propInfo mprop
          , too
          , keyVal "Instrument:" instInfo
          , chipDetails
          , fromMaybe mempty subArray
          , fromMaybe mempty (keyVal "Data Mode:" . toHtml <$> soDataMode)
          -- rely on the ToMarkup instance of ChandraTime
          , keyVal "Date:" (toHtml soStartTime)
          , expLink
          -- rely on the ToMarkup instance of RA
          , keyVal "Right Ascension:" (toHtml soRA)
          -- rely on the ToMarkup instance of Dec
          , keyVal "Declination:" (toHtml soDec)
          , keyVal "Roll:" (toHtml soRoll <> "\176") -- aka \u00b0, the degree symbol
          , fromMaybe mempty $ keyVal "Constellation:" <$> conLink soConstellation
          , jointElems
          , constraintElems
          ]

      -- ignore the thead element
      tbl = H.table (H.tbody tblRows)

  in (addClass "inactive" H.div H.! A.id "Details") 
      tbl

-- | Link to a proposal type.
propTypeLink :: PropType -> Maybe T.Text -> Html
propTypeLink propType mlbl =
  let lbl = fromMaybe (toPropTypeLabel propType) mlbl
      pLink = "/search/proptype/" <> H.toValue (fromPropType propType)
  in (H.a H.! A.href pLink) (toHtml lbl)

-- | Link to the TOO category. See also `tooLinkSearchLong`.
--
--   It is assumed that the input argument is valid.
tooLinkSearch :: Maybe TOORequestTime -> Html
tooLinkSearch too =
  let lbl = maybe "None" rtToLabel too
  in tooLinkSearchLong too lbl

-- | Link to the TOO category. See also `tooLinkSearch`.
--
--   It is assumed that the input argument is valid.
tooLinkSearchLong :: Maybe TOORequestTime -> T.Text -> Html
tooLinkSearchLong too lbl =
  let ttype = maybe "none" (T.toLower . rtToLabel) too
      uri = encodePathSegments ["search", "turnaround", ttype]
      uriVal = H.unsafeByteStringValue (toByteString uri)
  in (H.a H.! A.href uriVal) (toHtml lbl)


-- Note that there is a slight difference in the instrument and grating
-- search links: for instrument the "nice" conversion is used to create
-- the last element of the path (e.g. ACIS-I), rather than an internal
-- form (ACISI); this is not true for gratings since the "nice" form
-- looks like "Low Energy Transmission Grating" rather than "LETG".
--

-- | Add in a link to the instrument search page.
instLinkSearch :: Instrument -> Html
instLinkSearch inst = 
  let iLink = "/search/instrument/" <> H.toValue inst
  in (H.a H.! A.href iLink) (toHtml inst)

-- | Add in a link to the grating search page.
gratLinkSearch :: Grating -> Html
gratLinkSearch grat = 
  let gLink = "/search/grating/" <> H.toValue (show grat)
  in (H.a H.! A.href gLink) (toHtml grat)

-- | Add in a link to the combined instrument+grating search page.
igLinkSearch :: (Instrument, Grating) -> Html
igLinkSearch (inst, grat) = 
  let linkVal = "/search/instgrat/" <> H.toValue frag
      frag = show inst ++ "-" ++ show grat
      lbl = toHtml inst <> " with " <> toHtml grat
  in (H.a H.! A.href linkVal) lbl

-- | Add in a link to a "what is this" page for the
--   instrument.
instLinkAbout :: Instrument -> Html
instLinkAbout inst = 
  let iLink = "/about/instruments.html#" <> H.toValue inst
  in (H.a H.! A.href iLink) (toHtml inst)

-- | Add in a link to a "what is this" page for the
--   grating.
gratLinkAbout :: Grating -> Html
gratLinkAbout NONE = "no grating"
gratLinkAbout grat = 
  let linkVal = "/about/instruments.html#" <> H.toValue (show grat)
  in (H.a H.! A.href linkVal) ("the " <> toHtml grat)

{-
-- | Link to the general instruments page
igLinkAbout :: Html
igLinkAbout = (H.a H.! A.href "/about/instruments.html") "Chandra instruments"
-}

-- | Add in a link to the constellation search page.
constellationLinkSearch ::
  H.ToMarkup a
  => ConShort
  -> a
  -- ^ The link text
  -> Html
constellationLinkSearch con lbl = 
  let iLink = "/search/constellation/" <> H.toValue (fromConShort con)
  in (H.a H.! A.href iLink) (toHtml lbl)

typeLinkURI :: SimbadType -> B.ByteString
typeLinkURI st =
  let uri = ["search", "type", fromSimbadType st]
  in toByteString (encodePathSegments uri)

typeDLinkURI :: SimbadType -> B.ByteString
typeDLinkURI st =
  let uri = ["search", "dtype", fromSimbadType st]
  in toByteString (encodePathSegments uri)
  
-- | Add in a link to the object-type search page.
--
--  Note that we take care to encode the path because of special
--  characters in the Simbad type (in particular, '?').
--
typeLinkSearch ::
  H.ToMarkup a
  => SimbadType
  -> a
  -> Html
typeLinkSearch st lbl = 
  let iLink = H.unsafeByteStringValue (typeLinkURI st)
  in (H.a H.! A.href iLink) (toHtml lbl)

typeDLinkSearch ::
  H.ToMarkup a
  => SimbadType
  -> a
  -> Html
typeDLinkSearch st lbl = 
  let iLink = H.unsafeByteStringValue (typeDLinkURI st)
  in (H.a H.! A.href iLink) (toHtml lbl)

-- | Should this be a wrapper around typeLinkSearch or
--   typeDLinkSearch?
basicTypeLinkSearch :: Maybe SimbadType -> Html
basicTypeLinkSearch Nothing =
  (H.a H.! A.href "/search/type/unidentified") "Unidentified"
basicTypeLinkSearch (Just s) =
  let txt = fromMaybe "unknown SIMBAD type" (simbadTypeToDesc s)
  in typeLinkSearch s txt

-- | Add in a link to the obervation category search page.
categoryLinkSearch ::
  H.ToMarkup a
  => PropCategory
  -> a
  -> Html
categoryLinkSearch cat lbl = 
  let iLink = "/search/category/" <> H.toValue cat
  in (H.a H.! A.href iLink) (toHtml lbl)

-- | Add a link to the name-search for an object.
nameLinkSearch :: TargetName -> Html
nameLinkSearch name =
  let uriBS = toByteString (encodePath ["search", "name"] qry)
      uri = H.unsafeByteStringValue uriBS
      -- be explicit that query has a value
      qry = simpleQueryToQuery [("target", encodeUtf8 name)]
  in (H.a H.! A.href uri) (toHtml name)
    
jointLink :: JointMission -> AttributeValue
jointLink jm = H.toValue ("/search/joint/" <> fromMission jm)

-- | Create a link to the mission.
jointLinkSearch :: JointMission -> Html
jointLinkSearch jm =
  (H.a H.! A.href (jointLink jm)) (toHtml (fromMission jm))

-- | Link to the constraint search.
constraintLinkSearch :: Maybe ConstraintKind -> Html
constraintLinkSearch (Just cs) =
  let uri = H.toValue ("/search/constraints/" <> csToLC cs)
  in (H.a H.! A.href uri) (toHtml (csToLabel cs))
constraintLinkSearch Nothing =
  let uri = H.toValue ("/search/constraints/none" :: T.Text)
  in (H.a H.! A.href uri) "None"


